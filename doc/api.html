<!DOCTYPE html>
<html>
  <head>
    <title>JavaScript Algorithm Visualization (JSAV) API documentation</title>
    <style>
    .todo, .note {
      border: 2px solid red;
      border-radius: 4px;
      padding: 10px;
      background-color: #eee;
      font-weight: bold;
    }
    .note {
      border-color: green;
    }
    .todo:before, .note:before {
      content: "TODO: ";
      color: red;
      padding-right: 20px;
    }
    .note:before {
      content: "NOTE: ";
      color: green;
    }
    </style>
  </head>

<body>
<h1>Documentation for the JavaScript Algorithm Visualization API (JSAV) Version 0.1.2</h1>

<p class="note">
This documentation reflects the current status of the library.
It is a work-in-progress and subject to change!
</p>

<h2>Loading the Required Files</h2>
<p>
The easiest way to check the required files is to look at
the examples directory and copy one of those files as a template for
your new AV.
</p> 

<p>
If done manually, the files required (in this order) are as follows.
Note that <code>[JSAV]</code> refers to the relative position of the
JSAV library directory, which depends on where you are developing from.
</p> 

<ul>
  <li>jquery.transform: <code>[JSAV]/lib/jquery.transform.light.js</code></li>
  <li>Raphael: <code>[JSAV]/lib/raphael.js</code></li>
  <li>The library: Either <code>[JSAV]/build/jsav.js</code> or
      <code>[JSAV]/build/jsav-min.js</code>.
      This must always be included.</li>
</ul>
</p>

<p>
The main jQuery library must always be loaded.
jQuery UI and jquery.transform are only needed when you use the
library to show animations, such as using the data structures or
graphical primitives and modifying them. In other words, using
any other part of the library than the messaging API. Raphael is
only needed when using graphical primitives like circles and
rectangles.
</p>

<p>
In addition, developers must include the supporting .css file:
<code>[JSAV]/css/JSAV.css</code>
</p>

<h2>HTML Template for the Visualization</h2>

<p>
Visualizations generally include two parts:
HTML DOM elements, and JavaScript elements. 
The HTML section typical includes something like this:
</p> 

<pre>
  &lt;div id="container">
  &lt;div class="controls">&lt;/div>
  &lt;p class="output line">&lt;/p>
  &lt;/div>
</pre>
<dl>
  <dt><code>container</code></dt>
  <dd>This is the container element for the visualization</dd>
  <dt><code>controls</code></dt>
  <dd>The library will generate slideshow controls inside this
  element if your visualization uses the slideshow API</dd>
  <dt><code>output</code></dt>
  <dd>The area where the messages from the
      visualization will be displayed to the user.
      Type can further be specified using either
      class <code>line</code> or <code>scroll</code>.
      See the Messages API for more details.</dd>
</dl>

<h2>Creating A Visualization</h2>
<p>Initializing the visualization container is simple:</p>
<pre>var av = new JSAV("container");</pre>
<p>The <code>container</code> here refers to the id attribute of the
  container element (see the HTML template above).
  Alternatively, a DOM or jQuery element can be
  used as well. So, the following are alternative ways to achieve
  the same result:</p>
<pre>var av = new JSAV(document.getElementById("container"));
var av = new JSAV(jQuery("#container"));</pre>
    
<h2>Slideshow Support</h2>

<p>A slideshow is created by using a series of calls to the
  <code>.step()</code> method.
  Associated with each step, you use method calls to define or show
  the appropriate data structures and UI elements along with any
  actions to take place (such as swapping elements in an array or
  highlighting an element).</p>

<h3 class="apimethod">.step()</h3>
<p>Marks that a new step in the animation will start. Basically,
   everything within one step will be animated simultaneously when
   moving backward and forward.</p>

<p>
<b>Returns:</b> A JSAV object. Thus, this method may be chained with,
for example, the <code>umsg</code> method.
</p>

<h3 class="apimethod">.recorded()</h3>
<p>
A call to this method is placed at the end of the series of
<code>.step()</code> method calls to start the slideshow.
</p>

<h3>The <code>counter</code> element</h3>
<p>
A slideshow counter showing the position in slideshow (e.g. 2/120) can
be added by including a DOM element with class <code>counter</code>
inside the <code>container</code>.
For example, you can add
<code>&lt;span class="counter">&lt;/span></code> to some DOM element
to attach the counter.
</p>


<h2>Messages API</h2>

<p>
The Messages API allows the user to control the contents of the output
message buffer intended for informing the user about the state of the
visualization or for providing directions.</p>

<p>
The output buffer will have been specified in the HTML section of the
document. It is defined as an empty paragraph of class
<code>output</code>, with one of the following class options.
</p>
<p>
<code>class="output line"</code> indicates a small "line-style"
message buffer where typically each line overwrites the previous one.
</p>
<p>
<code>class="output scroll"</code> indicates a visible textbox with a
scrollbar. The textbox is only cleared when explicitly directed by a
<code>.clearumsg()</code> call.
Since this acts as a normal HTML paragraph,
optional standard parameters can be used such as
<code>readonly="readonly"</code> to make 
the textbox unwriteable by the user, or to
override the default height and width.
</p>

<h3 class="apimethod">.umsg(msg[, options])</h3>
<p>
Add the given message <code>msg</code> to the message
output. The optional <code>options</code> parameter
can be an object whose properties specify the
behavior. Currently, only <code>color</code> property is used (when
present) to change the color of the message.
Use would look something like:
</p>
<pre>
av.umsg("My message here", {"color": "blue"});
</pre>
<p>
Since the
<code>msg</code> is output as standard HTML, the style of
the message text can also be controlled by using HTML commands.
</p>

<p>
<b>Returns:</b> A JSAV object. Thus, this method may be chained with,
for example, the <code>step</code> method.
</p>


<h3 class="apimethod">.clearumsg()</h3>
<p>Clear the contents of the output message buffer.</p>

<h2>Array Data Structure API</h2>

<p>
JSAV will ultimately provide layout support for a number of standard
data structures. Presently, only arrays are supported, as described in
this section.
</p>

<h3 class="apimethod">.ds.array(element[, options]) and
.ds.array(Array[, options])</h3>
<p>
An array can be created using the .ds.array method on a JSAV instance.
It takes one parameter indicating either a DOM/jQuery Element
(ul or ol) or a JavaScript Array.
For example, to initialize and add to the visualization an array with
four elements:</p>
<pre>var arr = av.ds.array([10, 13, 99, 25]);</pre>

<p>
Array indexing begins at zero.
</p>

<p>The returned array instance is controlled through a collection of
methods explained next. Note that changes to the array contents must
go through this API (the <code>.value</code> method),
since the array contents must be managed by
JSAV rather than by the developer.
</p>

<p>Options that the second, optional, parameter can specify:</p>
<ul>
<li>layout: Defines choices of layout (bars for example). Details to
      come.</li>
<li>indexed: Boolean to determine if array indices are shown or not.</li>
<li>visible: Boolean to determine if initially the array is shown or
      not.</li>
</ul>

<h3 class="apimethod">.clone()</h3>
<p>
Create and return a clone of an array.
The clone will remain invisible until the <code>show</code>
method is called on it.
</p>

<h3 class="apimethod">.css(indices, css)</h3>
<p>
Apply the given CSS properties to the specified <code>indices</code>.
Parameter <code>indices</code> can be a number, array, or function like for 
the <code>highlight</code> method.
The argument <code>css</code> should be an object with property
name-and-value pairs.
For example, to make
positions 0 and 4 have green color and lightgray background:
</p>
<pre>
arr.css([0, 4], {"color": "green", "background-color": "#eee"});
</pre>

<p>
<b>Returns:</b> a JSAV array object. Thus, this method can be chained.
</p>

<h3 class="apimethod">.hide()</h3>
<p>
Make the array invisible.
</p>

<h3 class="apimethod">.highlight()</h3>
<p>
Call to <code>highlight</code> without any parameters will highlight
all elements in the array.
Note that this will only apply the CSS class <code>highlight</code> to
the array elements.
It is up to the author to make sure the loaded CSS files include such
styling.
</p>

<p>
<b>Returns:</b> a JSAV array object. Thus, this method can be chained.
</p>

<h3 class="apimethod">.highlight(number)</h3>
<p>
Highlight the given index number.
</p>

<h3 class="apimethod">.highlight(indexlist)</h3>
<p>
Highlight the indices in the given <code>indexlist</code>.
For example, the following would highlight array positions 1, 2, and 5.
</p>
<pre>arr.highlight([1, 2, 5]);</pre>

<h3 class="apimethod">.highlight(function)</h3>
<p>
Highlights all the indices that the passed function returns true.
For example, to highlight all even indices:</p> 
<pre>arr.highlight(function(index) { return index%2==0; });</pre>

<h3 class="apimethod">.show()</h3>
<p>
Make the array visible.
</p>

<h3 class="apimethod">.size()</h3>
<p>
Returns the size of the array.
For the array defined in the array creation example above,
the following would return 4:
</p>
<pre>arr.size();</pre>
    
<h3 class="apimethod">.swap(index1, index2)</h3>
<p>Swaps the contents (and graphics state) of the two array positions.</p>
    
<h3 class="apimethod">.unhighlight(indices)</h3>
<p>
Removes the highlight from the given <code>indices</code>.
There are corresponding versions of this function with parameters like
for highlight.
</p>

<p>
<b>Returns:</b> a JSAV array object. Thus, this method can be chained.
</p>

<h3 class="apimethod">.value(index)</h3>
<p>Returns the value of the element at the given index.</p>
    
<h3 class="apimethod">.value(index, newValue)</h3>
<p>
Sets the value of the element at the given index to the given value.
</p>

<h3 class="apitopic">Extending the Array</h3>
<p class="todo">
Example of extending to provide .opacity(indices, value) function as a
shortcut to set the opacity of indices.
</p> 
    
<h2>Label API</h2>

UI elements such as arrays can take a label.

<h3 class="apimethod">.label(msg, options)</h3>
<p>
This is a method of the AV object.
It creates a label that is associated with some UI element of the AV
specified by the options.
Parameter <code>msg</code> is the
(initial) value for the label.
Paramter <code>options</code> include the following:
</p>
<ul>
<li> <code>{before: &lt;UI element>}</code> Set the label before element
<code>UI element</code>
<li> <code>{after: &lt;UI element>}</code> Set the label after element
<code>UI element</code>
<li> <code>{display: &lt;boolean>}</code> Determine whether the label
is visible on creation.
</ul>

<h3 class="apitopic">.hide()</h3>
<p>
Make the label invisible.
</p>

<h3 class="apitopic">.show()</h3>
<p>
Make the label visible.
</p>

<h3 class="apitopic">.text(msg)</h3>
<p>
Set the text for the label. If the <code>msg</code> parameter is left
out, this method will return the current text of the label.
</p>

<h2>Best Practice for Modularity</h2>

<p>
When you create a visualization, you might want to make it easy for
other people to use.
Some simple steps will make it easy for others to include your
visualization within their own HTML pages using a
simple <code>iframe</code> tag.
The library is set up to make it natural for your visualization to
reside within the <code>container</code> element.
There is no margin or padding around the <code>container</code>, and
it has a one-pixel-wide black border.
So long as you stay within this, an <code>iframe</code> can include
your whole visualization without any disruption to the user's page.
If you would like to support mobiles, you will probably want to keep
the full size of your <code>container</code> at most 800 by 435 pixels.
A visualization can then be embedded with a call such as:
</p>

<pre>
&lt;iframe src="http://algoviz.org/OpenDSA/trunk/AV/shellsort.html"
   width="824" height="459" frameborder="0" marginwidth="0"
   marginheight="0" scrolling="no">
&lt;/iframe>
</pre>


</body>
</html>
