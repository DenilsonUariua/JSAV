<!DOCTYPE html>
<html>
<head>
  <title>Shellsort Presentation v0.3.0: Alternate Version</title>
  <meta charset="utf-8" />
  <link href="AeBookAV.css" title="CSS" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" href="../css/JSAV.css" media="screen" />
</head>

<body>
<style>
  #container {
    width: 800px;
    height: 400px;
    background-color: #efe;
  }

  #container .jsavarray {
     left: -10px;
  }

  p.jsavoutput.jsavline {
    height: 80px;
    margin: 10px, 0px;
  }
</style>

<script src="http://code.jquery.com/jquery-1.6.1.js"></script>
<script
  src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.13/jquery-ui.min.js">
</script>
<script src="../lib/jquery.transform.light.js"></script>
<script src="../build/JSAV-min.js"></script>

<input type="button" name="about" value="About"/>

<script>
  var LIGHT = "rgb(215, 215, 215)";  // For "greying out" array elements
  var DARK = "black";                // Make array elements dark again

  // Connect action callbacks to the HTML entities
  $('input[name="about"]').click(about);

  // Process About button: Pop up a message with an Alert
  function about() {
    var mystring = "Shellsort Explanation Slideshow\nWritten by Cliff Shaffer and Ville Karavirta\nCreated as part of the OpenDSA hypertextbook project.\nFor more information, see http://algoviz.org/eBook\nWritten during June, 2011\nLast update: August 14, 2011\nJSAV library version " + JSAV.version();
    alert(mystring);
  }
</script>

<div id="content">
<h1>Shellsort Tutorial</h1>
</div>

<p>
Shellsort was named after its inventor, D.L. Shell.
It is also sometimes called the <b>diminishing increment</b> sort.
Unlike Insertion Sort and Selection Sort, there is no real-life
intuitive equivalent for Shellsort.
Unlike the exchange sorts, Shellsort makes comparisons and
swaps between non-adjacent elements.
Shellsort also exploits the best-case performance of Insertion Sort.
Shellsort's strategy is to quickly make the list ``mostly sorted''
so that a final Insertion Sort can finish the job.
When properly implemented, Shellsort will give
substantially better performance than &theta;(n<sup>2</sup>)
in the worst case.

<p>
Shellsort uses a process that forms the basis for many of the sorts
presented in the following sections: Break the list into sublists,
sort them, then recombine the sublists.
Shellsort does this in an unusual way, breaking its input
into ``virtual'' sublists.
Each sublist is sorted using an Insertion Sort.
Another group of sublists is then chosen and sorted, and so on.
</p>

<p>
Shellsort provides a huge improvement over O(<i>n</i><sup>2</sup>)
sorts like Insertion Sort.
It works by taking advantage of the fact that Insertion Sort works
very well (in linear time) when the list is nearly sorted.
Shellsort works by performing a series of Insertion Sorts on carefully
selected sublists, first on small sublists and then on increasingly
large sublists.
</p>

<p>
During each iteration, Shellsort breaks the list into disjoint
sublists so that each element in a sublist is a fixed number of
positions apart.
For example, let us assume for convenience that <i>n</i>,
the number of values to be sorted, is a power of two.
</p>

<p>
One possible implementation of Shellsort will begin by breaking the
list into <i>n</i>/2 sublists of 2 elements each, where the array
index of the 2 elements in each sublist differs by <i>n</i>/2.
We say that the increment is <i>n</i>/2.
If there are 16 elements in the array indexed from 0
to 15, there would initially be 8 sublists of 2 elements each.
</p>


<p>
The first sublist would be the elements in positions 0 and 8.
The second is in positions 1 and 9, and so on.

<style>
  #container1 {
    width: 760px;
    height: 135px;
    background-color: #efe;
  }
</style>

<center>
<div id="container1">
  <table id=tableT1 style="margin-top:-15px; margin-bottom:-15px">
    <tr>
      <td width=100><span class="jsavcounter"></span></td>
      <td width=650px>
    	<div class="jsavcontrols"></div>
      </td>
    </tr>
  </table>
</div>
</center>

<script>
(function($) {
  var av1 = new JSAV("container1"); //containing HTML element with id container
  av1.SPEED = 150; // Set the animation speed base

  // Create an array object under control of JSAV library
  var arr1 = av1.ds.array([20, 30, 12, 54, 55, 11, 78, 14, 13, 79, 44,
      98, 76, 45, 32, 11], {indexed: true});

  // set color to LIGHT for the whole array, then highlight indices 0 and 8
  arr1.css(function(index)
    { return index%8 != 0;}, {"color": LIGHT}).highlight([0, 8]);
  // another way to specify a message for a step
  av1.step();
  arr1.unhighlight([0, 8]).css([0, 8], {"color": LIGHT}).highlight([1, 9]);
  
  av1.step();
  for (var i=2; i<8; i++) { // loop through the rest of the array sublists
    av1.step();
    arr1.unhighlight([i-1, i+7]).css([i-1, i+7], {"color": LIGHT}).highlight([i, i+8]);
  }

  av1.recorded();
})(jQuery);
</script>

<p>
Each of these sublists of length two is sorted using Insertion Sort.
(The blue elements are being compared. The are swapped if appropriate.)
</p>

<div id="container">
  <table id=tableT style="margin-top:-15px; margin-bottom:-15px">
    <tr>
      <td width=100><span class="jsavcounter"></span></td>
      <td width=650px>
    	<div class="jsavcontrols"></div>
      </td>
      <td>
        <a class="jsavsettings" href="#">Settings</a>
      </td>
    </tr>
  </table>
  <p class="jsavoutput jsavline"></p>
</div>

<script>
  // Various functions that will be used by all of the following
  // sections of the tutorial.

  // Convenience function for setting another type of highlight
  // (will be used for showing which elements will be compared during sort)
  var setBlue = function(arr, index) {
    arr.css(index, {"background-color": "#ddf" });
  };

  // Partial Shellsort. Sweep with the given increment
  function sweep(av, myarr, incr) {
    var j = 0;
    highlightFunction = function(index) { return index%incr == j;};
    for (j=0; j<incr; j++) {         // Sort each sublist
      // Highlight the sublist
      myarr.highlight(highlightFunction);
      av.step();
      inssort(av, myarr, j, incr);
      myarr.unhighlight(highlightFunction);
    }
  }

  // Insertion sort using increments
  function inssort(av, arr, start, incr) {
    var i, j;
    for (i=start+incr; i<arr.size(); i+=incr) {
      setBlue(arr, i);
      for (j=i; j>=incr; j-=incr) {
        setBlue(arr, j-incr);
	av.step();
        if (arr.value(j) < arr.value(j-incr)) {
          arr.swap(j, j-incr); // swap the two indices
          av.step();
	}
        else {
  	  arr.highlight([j-incr, j]);
          break; // Done pushing element, leave for loop
        }
	arr.highlight(j);
      }
      arr.highlight(j);
    }
  }
</script>

<script>
(function($) {
  var LIGHT = "rgb(215, 215, 215)";  // For "greying out" array elements
  var DARK = "black";                // Make array elements dark again

  var av = new JSAV("container");
  av.SPEED = 200; // Set the animation speed base

  // Create an array object under control of JSAV library
  var arr = av.ds.array([20, 30, 12, 54, 55, 11, 78, 14, 13, 79, 44,
      98, 76, 45, 32, 11], {indexed: true});

  // Make a label before the array, and give it an empty string to
  // take up the appropriate space since we don't want to see the
  // label initially.
  var arrlabel = av.label("&nbsp;", {before: arr});

  // Cloned copy of array for holding the original value positions.
  // Will be shown later to compare against progress made by the algorithm
  origarr = arr.clone();

  arr.unhighlight(); // unhighlight seems to have the side effect of
                     // making the cell dark.

  sweep(av, arr, 8); // first sweep with increment 8

  av.step().umsg('At the end of the first pass, the resulting array is "a little better sorted".');

  arr.unhighlight();

  arr.css(function(index)
    { return arr.value(index) !== origarr.value(index); }, {"color": "#0f0"});

  arrlabel.text("Values in <b style='color:#0f0;'>green</b> were swapped during this pass");
  origarr.show();
  var origlabel = av.label("Original Array:", {before: origarr});

  av.step().umsg("The second pass of Shellsort looks at fewer, bigger lists. For our example the second pass would have n/4 lists of size 4, with the increment being n/4 = 4. Thus, the second pass would have as its first sublist the 4 elements in positions 0, 4, 8, and 12...");

  arrlabel.text("&nbsp;");
  origarr.hide();
  origlabel.hide();

  arr.css(function(index)
    { return index%4 != 0;}, {"color": LIGHT}).highlight([0, 4, 8, 12]);

  av.step().umsg("... the second sublist would have elements in positions 1, 5, 9, and 13 ...");
  arr.unhighlight([0, 4, 8, 12]).css([0, 4, 8, 12], {"color": LIGHT}).highlight([1, 5, 9, 13]);

  av.step().umsg("and so on.");
  arr.unhighlight([1, 5, 9, 13]).css([1, 5, 9, 13], {"color": LIGHT}).highlight([2, 6, 10, 14]);

  av.step();
  arr.unhighlight([2, 6, 10, 14]).css([2, 6, 10, 14], {"color": LIGHT}).highlight([3, 7, 11, 15]);

  av.step().umsg("Each sublist of four elements would also be sorted using an Insertion Sort.");

  arr.unhighlight();

  sweep(av, arr, 4); // second sweep with increment 4

  av.step().umsg("At the end of processing sublists with increment 4, the array is \"even more sorted\".");

  arr.css(function(index)
    { return arr.value(index) !== origarr.value(index); }, {"color": "#0f0"});

  arrlabel.text("Values in <b style='color:#0f0;'>green</b> have been swapped from their original positions.");
  origarr.show();
  origlabel.show();

  av.step().umsg("The third pass would be made on sublists with increment 2. This means we process two lists, one consisting of the odd positions and the other consisting of the even positions.");

  arr.css(function(index) {return index}, {"color": DARK});

  arrlabel.text("&nbsp;");
  origarr.hide();
  origlabel.hide();

  arr.highlight([0, 2, 4, 6, 8, 10, 12, 14]);
  av.step();
  arr.unhighlight([0, 2, 4, 6, 8, 10, 12, 14]).highlight([1, 3, 5, 7, 9, 11, 13, 15]);

  av.step().umsg("As usual, we sort the sublists using Insertion Sort.");
  arr.unhighlight();

  av.step();
  arr.unhighlight();

  sweep(av, arr, 2);

  av.step().umsg("And here is the result of the third pass. The list is getting even more sorted!");
  arr.unhighlight();

  av.step().umsg("The culminating pass in this example would be a \"normal\" Insertion Sort of all elements.");

  arr.highlight();
  av.step();

  inssort(av, arr, 0, 1);

  av.step().umsg("Finally, the array is sorted.");
  arr.unhighlight();
  av.recorded();

})(jQuery);
</script>

<p>
Next, you can try running Shellsort on an array of your chosen size,
with either random data or data that you select.
You can also set the increment series.
</p>

<center>
 <iframe src="shellsort-av.html"
	 type="text/javascript" width="800" height="490"
	 frameborder="0" marginwidth="0" marginheight="0"
	 scrolling="no">
</iframe>
</center>

<p>
Now test yourself to see how well you understand Shellsort.
</p>

<center>
 <iframe src="ShellsortProficiency.html"
	 type="text/javascript" width="842" height="480"
	 frameborder="0" marginwidth="0" marginheight="0"
	 scrolling="no">
</iframe>
</center>

<p>
Some choices for the series of increments will make Shellsort
run more efficiently than others.
In particular, the choice of increments described above (2<sup>k</sup>,
2<sup>k-1</sup>, ..., 4, 2, 1) turns out to be relatively inefficient.
A better choice is the following series based on "division by three":
(..., 121, 40, 13, 4, 1).
</p>

<center>
 <iframe src="ShellsortPerformance.html"
	 type="text/javascript" width="842" height="410"
	 frameborder="0" marginwidth="0" marginheight="0"
	 scrolling="no">
</iframe>
</center>

<p>
The analysis of Shellsort is difficult, so we must accept without
proof that the average-case performance of Shellsort (for ``divisions
by three'' increments) is O(n&radic;n).
Other choices for the increment
series can reduce this upper bound somewhat.
Thus, Shellsort is substantially better than Insertion Sort,
or any of the other &theta;(n<sup>2</sup>) sorts presented earlier.
In fact, Shellsort is not so much worse than the
asymptotically better sorts to be presented whenever <i>n</i> is of medium
size (thought is tends to be a little slower than these other
algorithms when they are well implemented).
Shellsort illustrates how we can sometimes exploit the special properties
of an algorithm (in this case Insertion Sort) even if in general that
algorithm is unacceptably slow.
</p>
</body>
</html>
