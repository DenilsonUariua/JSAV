<!DOCTYPE html>
<html>
<head>
  <title>Shellsort v0.0.01</title>
  <link rel="stylesheet" href="JSAV.css" type="text/css" media="screen" title="no title" charset="utf-8" />
</head>
<body>
<div id="container">
  <div class="controls"></div>
  <p class="output line"></p>
</div>
<script src="http://code.jquery.com/jquery-1.6.1.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.13/jquery-ui.min.js"></script>
<script src="../lib/jquery.transform.js/jquery.transform.light.js"></script>
<script src="../lib/raphael/raphael.js"></script>
<script src="../build/JSAV.js"></script>
<script>
  // this is what I would imagine the ShellSort visualization implementation 
  // might look like

  var av = new JSAV("container"); //containing HTML element with id container
  //var arr = av.ds.array($("#initialarray")),
  // HTML element containing the initial array, id initialarray
  // alternatively, generate from data: 
  var arr = av.ds.array([20, 30, 12, 54, 55, 11, 78, 14, 13, 79, 44, 98, 76, 45, 32, 12]);
  // or, generate from random data: var arr = av.ds.array.random(10);
  // size as param, range as params as well??

  origarr = arr.clone(); // clone for showing the array comparison, not added to document yet (not showed)

  av.umsg("During each iteration, Shellsort breaks the list into disjoint sublists so that each element in a sublist is a fixed number of positions apart. For example, let us assume for convenience that n, the number of values to be sorted, is a power of two."); // message to be shown initially
  // create a new step to the visualization, a given message
  av.step().umsg("One possible implementation of Shellsort will begin by breaking the list into n/2 sublists of 2 elements each, where the array index of the 2 elements in each sublist differs by n/2. We say that the increment is n/2. If there are 16 elements in the array indexed from 0 to 15, there would initially be 8 sublists of 2 elements each. The first sublist would be the elements in positions 0 and 8...");

  // av.ds.variable("increment", 8); // display a variable named increment with value 8
  // set opacity to 0.5 for the whole array, then highlight indices 0 and 8
  arr.css(function(index, item)
    { return index%8 != 0;}, {"opacity": 0.5}).highlight([0, 8]);
  // another way to specify a message for a step
  av.step().umsg("... the second in positions 1 and 9...");
  arr.unhighlight().highlight([1, 9]);
  for (var i=2; i<8; i++) { // loop through the rest of the array sublists
    av.step().umsg("... and so on ...");
    console.log("unhighlighting ", i-1, i+7, "highlighting", i, i+8);
    arr.unhighlight([i-1, i+7]).highlight([i, i+8]);
  }

  av.step().umsg("Each of these sublists of length two is sorted using Insertion Sort.");
  arr.unhighlight([7, 15]);
  //arr.unhighlight([7, 15]).highlight([0, 8]);
  shellsort(arr, 8); // first sweep with increment 8

  av.step().umsg('At the end of the first pass, the resulting array is "a little better sorted".');
  arr.unhighlight();
  //arr.title("Array after sorting the sublists with increment 8:");
  //origarr.insertBefore(arr).show().title("Original Array:"); // add the origarr before (that is, above) the partly-sorted array
  av.step().umsg("The second pass of Shellsort looks at fewer, bigger lists. For our example the second pass would have n/4 lists of size 4, with the increment being n/4 = 4. Thus, the second pass would have as its first sublist the 4 elements in positions 0, 4, 8, and 12â€¦");
  // av.ds.variable("increment", 4); // set the value of variable increment to 4
  arr.css("opacity", 0.5).highlight([0, 4, 8, 12]); // on slide 10

  av.step().umsg("... the second sublist would have elements in positions 1, 5, 9, and 13 ...");
  arr.unhighlight([0, 4, 8, 12]).highlight([1, 5, 9, 13]); // slide 11

  av.step().umsg("and so on.");
  arr.unhighlight([1, 5, 9, 13]).highlight([2, 6, 10, 14]);

  av.step().umsg("and so on.");
  arr.unhighlight([2, 6, 10, 14]).highlight([3, 7, 11, 15]);

  av.step().umsg("Each sublist of four elements would also be sorted using an Insertion Sort.")
  shellsort(arr, 4); // second sweep with increment 4

  av.step().umsg("At the end of processing sublists with increment 4, the array is \"even more sorted\".");
  arr.unhighlight();

  av.step().umsg("The third pass would be made on sublists with increment 2. This means we process two lists, one consisting of the odd positions and the other consisting of the even positions.");
  //  av.ds.variable("increment", 2); // set the value of variable increment to 2
  arr.highlight([0, 2, 4, 6, 8, 10, 12, 14]);
  arr.unhighlight([0, 2, 4, 6, 8, 10, 12, 14]).highlight([1, 3, 5, 7, 9, 11, 13, 15]);
  arr.unhighlight([1, 3, 5, 7, 9, 11, 13, 15]).highlight([0, 2, 4, 6, 8, 10, 12, 14]);

  av.step().umsg("As usual, we sort the sublists using Insertion Sort.");
  arr.unhighlight();
  shellsort(arr, 2);

  av.step().umsg("And here is the result of the third pass. The list is getting even more sorted!");
  arr.unhighlight();

  av.step().umsg("The culminating pass in this example would be a \"normal\" Insertion Sort of all elements.");
  inssort2(arr, 0, 1);

  av.step().umsg("Finally, the array is sorted.");
  arr.unhighlight();
  $("#forward").click(function() {
    $("#container").trigger("forward");
  });
  $("#backward").click(function() {
    $("#container").trigger("backward");
  });
  av.recorded();

  // partial shellsort. sweep with the given increment
  function shellsort(myarr, incr) {
    var j = 0;
    for (; j<incr; j++) {         // Sort each sublist
      av.substep();
      myarr.highlight(function(index, item) { return index%j === 0;}); // a function for highlight that will highlight all indices for which it returns true
      inssort2(myarr, j, incr);
      av.step();
      myarr.unhighlight();
      myarr.css(function(index, item) { return index%j === 0;}, {"color": "green"}); // a function for css that will style all indices for which it returns true
      av.stepdone();
    }
    //inssort2(arr, 0, 1);     // Could call regular inssort here
  }

  function inssort2(myarr, start, incr) {
    for (var i=start+incr; i<myarr.size(); i+=incr) {
      for (var j=i; j>=incr && (myarr.value(j) < myarr.value(j-incr)); j-=incr) {
        // should we highlight the compared items first?
        av.substep(); // create new substeps for each swap
        myarr.swap(j, j-incr); // swap the two indices
        av.stepdone();
      }
    }
  }

</script>
</body>
</html>
