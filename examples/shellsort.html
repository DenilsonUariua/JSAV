<!DOCTYPE html>
<html>
<head>
  <title>Shellsort v0.0.01</title>
  <meta charset="utf-8" />
  <link href="hypertextbook.css" title="CSS" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" href="../css/JSAV.css" media="screen" />
</head>
<body>
<style>
  #container {
    width: 880px;
    height: 400px;
    background-color: #efe;
  }
  #container .array {
     left: -10px;
  }
  p.output.line {
    height: 100px;
  }
</style>
<div id="container">
  <div class="controls"></div>
  <p class="output line"></p>
</div>
<script src="http://code.jquery.com/jquery-1.6.1.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.13/jquery-ui.min.js"></script>
<script src="../lib/jquery.transform.js/jquery.transform.light.js"></script>
<script src="../lib/raphael/raphael.js"></script>
<script src="../build/JSAV.js"></script>
<script>
  var LIGHT = "rgb(215, 215, 215)";  // For "greying out" array elements
  var DARK = "black";                // Make array elements dark again
  // Convenience function for setting another type of highlight
  // (will be used for showing insertion sort)
  var setBlue = function(index) {
    arr.css(index, {"background-color": "#ddf" });
  };

  var av = new JSAV("container"); //containing HTML element with id container
  av.SPEED = 200;

  // message to be shown initially
  av.umsg("Shellsort provides a huge improvement over O(n<sup>2</sup>) sorts sorts like Insertion Sort. It works by taking advantage of the fact that Insertion Sort works very well (in linear time) when the list is nearly sorted. Shellsort works by performing a series of Insertion Sorts on carefully selected sublists, first on small sublists and then on increasingly large sublists.");

  // create a new step to the visualization, a given message
  av.umsg("During each iteration, Shellsort breaks the list into disjoint sublists so that each element in a sublist is a fixed number of positions apart. For example, let us assume for convenience that n, the number of values to be sorted, is a power of two.");

  av.step().umsg("One possible implementation of Shellsort will begin by breaking the list into n/2 sublists of 2 elements each, where the array index of the 2 elements in each sublist differs by n/2. We say that the increment is n/2. If there are 16 elements in the array indexed from 0 to 15, there would initially be 8 sublists of 2 elements each.");

  //var arr = av.ds.array($("#initialarray")),
  // HTML element containing the initial array, id initialarray
  // alternatively, generate from data: 
  var arr = av.ds.array([20, 30, 12, 54, 55, 11, 78, 14, 13, 79, 44,
      98, 76, 45, 32, 11], {indexed: true});
  // or, generate from random data: var arr = av.ds.array.random(10);
  // size as param, range as params as well??

  origarr = arr.clone(); // clone for showing the array comparison, not added to document yet (not shown)

  av.step().umsg(" The first sublist would be the elements in positions 0 and 8...", {preserve: true});

  // set color to LIGHT for the whole array, then highlight indices 0 and 8
  arr.css(function(index, item)
    { return index%8 != 0;}, {"color": LIGHT}).highlight([0, 8]);
  // another way to specify a message for a step
  av.step().umsg("... the second in positions 1 and 9...");
  arr.unhighlight([0, 8]).css([0, 8], {"color": LIGHT}).highlight([1, 9]);
  
  av.step().umsg("... and so on ...");
  for (var i=2; i<8; i++) { // loop through the rest of the array sublists
    av.step();
    arr.unhighlight([i-1, i+7]).css([i-1, i+7], {"color": LIGHT}).highlight([i, i+8]);
  }

  av.step().umsg("Each of these sublists of length two is sorted using Insertion Sort.");
  arr.unhighlight([7, 15]).css([7, 15], {"color": LIGHT});

  sweep(arr, 8); // first sweep with increment 8

  av.step().umsg('At the end of the first pass, the resulting array is "a little better sorted".');

  arr.unhighlight();

  arr.css(function(i, item)
    { return arr.value(i) !== origarr.value(i); }, {"color": "#0f0"});

  var arrlabel = av.label("Values in green were swapped during this pass", {before: arr});
  origarr.show();
  var origlabel = av.label("Original Array:", {before: origarr});

  av.step().umsg("The second pass of Shellsort looks at fewer, bigger lists. For our example the second pass would have n/4 lists of size 4, with the increment being n/4 = 4. Thus, the second pass would have as its first sublist the 4 elements in positions 0, 4, 8, and 12...");

  origarr.hide();
  origlabel.hide();
  arrlabel.hide();

  // av.ds.variable("increment", 4); // set the value of variable increment to 4
  arr.css(function(index, item)
    { return index%4 != 0;}, {"color": LIGHT}).highlight([0, 4, 8, 12]);

  av.step().umsg("... the second sublist would have elements in positions 1, 5, 9, and 13 ...");
  arr.unhighlight([0, 4, 8, 12]).css([0, 4, 8, 12], {"color": LIGHT}).highlight([1, 5, 9, 13]);

  av.step().umsg("and so on.");
  arr.unhighlight([1, 5, 9, 13]).css([1, 5, 9, 13], {"color": LIGHT}).highlight([2, 6, 10, 14]);

  av.step().umsg("and so on.");
  arr.unhighlight([2, 6, 10, 14]).css([2, 6, 10, 14], {"color": LIGHT}).highlight([3, 7, 11, 15]);

  av.step().umsg("Each sublist of four elements would also be sorted using an Insertion Sort.");

  arr.unhighlight([3, 7, 11, 15]).css([3, 7, 11, 15], {"color": LIGHT});

  sweep(arr, 4); // second sweep with increment 4

  av.step().umsg("At the end of processing sublists with increment 4, the array is \"even more sorted\".");

  arr.css(function(i, item)
    { return arr.value(i) !== origarr.value(i); }, {"color": "#0f0"});

  arrlabel.show();
  origarr.show();
  origlabel.show();

  av.step().umsg("The third pass would be made on sublists with increment 2. This means we process two lists, one consisting of the odd positions and the other consisting of the even positions.");

  origarr.hide();
  origlabel.hide();
  arrlabel.hide();

  //  av.ds.variable("increment", 2); // set the value of variable increment to 2

  arr.highlight([0, 2, 4, 6, 8, 10, 12, 14]);
  av.step();
  arr.unhighlight([0, 2, 4, 6, 8, 10, 12, 14]).highlight([1, 3, 5, 7, 9, 11, 13, 15]);
  av.step();
  arr.unhighlight([1, 3, 5, 7, 9, 11, 13, 15]).highlight([0, 2, 4, 6, 8, 10, 12, 14]);

  av.step().umsg("As usual, we sort the sublists using Insertion Sort.");
  arr.unhighlight();

  av.step();
  sweep(arr, 2);

  av.step().umsg("And here is the result of the third pass. The list is getting even more sorted!");
  arr.unhighlight();

  av.step().umsg("The culminating pass in this example would be a \"normal\" Insertion Sort of all elements.");

  arr.highlight();
  av.step();

  inssort(arr, 0, 1);

  av.step().umsg("Finally, the array is sorted.");
  arr.unhighlight();
  $("#forward").click(function() {
    $("#container").trigger("forward");
  });
  $("#backward").click(function() {
    $("#container").trigger("backward");
  });
  av.recorded();

  // Partial Shellsort. Sweep with the given increment
  function sweep(myarr, incr) {
    var j = 0;
    for (; j<incr; j++) {         // Sort each sublist
      // Highlight the sublist
      var highlightArray = [];
      for (var k=0; k < myarr.size(); k++) {
        if (k%incr == j) {
          highlightArray.push(k);
        }
      }
      myarr.highlight(highlightArray);
      //myarr.highlight(function(index, item) { return index%incr == j;});
      av.step();
      inssort(myarr, j, incr);
      myarr.unhighlight();
    }
  }

  // Insertion sort using increments
  function inssort(A, start, incr) {
    var i, j;
    for (i=start+incr; i<A.size(); i+=incr) {
      setBlue(i);
      av.step();
      for (j=i; j>=incr && (A.value(j) < A.value(j-incr)); j-=incr) {
        A.swap(j, j-incr); // swap the two indices
        av.step();

	setBlue(j-incr);
	arr.highlight(j);
        av.step();
      }
      arr.highlight(j);
    }
  }

</script>
</body>
</html>
